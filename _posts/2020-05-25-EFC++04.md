---
title: Effective C++ 04 C++的缺省类方法
tags: 
  - C++程序设计
---

这是Effective C++的学习记录。

## 条款05：C++的缺省类方法

C++会为Class自动补全一些方法和函数。C++规范中，Class默认带有(比如对于一个

```cpp
class example { 
    /*empty*/
};
```

- 默认构造函数 `example()`
- 复制构造函数 `example(const example& a)`
- 默认析构函数 `~example()`，此函数不具有任何的`virtual`性质
- 重载赋值运算符 `example& operator=(const example& a)`

但是，如果一旦为函数定义了任何的构造函数(无论是否含参)，编译器将不再为它创建默认构造函数(不含参的构造函数)。  
而如果类内存在引用类型的成员和Const成员，编译器将不会生成默认的复制构造函数和重载赋值运算符：因为C++不允许引用改指向另一个实例；编译器也不知道如何面对修改Const成员这一问题。  
如果你的类含有引用类型的成员和Const成员，你应该自己为其定义赋值运算符。

## 条款06：若不希望使用缺省方法，应该怎么做？

如果我们不希望使一个类实例从另一个类实例上赋值，我们就需要使用某种方法使缺省类方法失效。

缺省类方法可以省略的只有复制构造函数和赋值运算符可能被省略。 
省略的方式之一就是如上所述，引入一个不允许被修改的成员。

更为普遍的做法是为类声明一个没有定义的复制构造函数和赋值运算符：

```cpp
class example {
    int value;
public:
    example(const example& a);
    example& operator=(const example& a);
}
```

我们在后边不实现它，那么用户调用的时候就会调用一个没有实现的函数而引发连接器错误，但是这可能会引发用户的不满。因此：

```cpp
class example {
private:
    int value;
    example(const example& a);
    example& operator=(const example& a);
}
```

我们使用private限定符来阻止用户从外部调用它，即使用户从友元调用它，它也会报错。  
这个方案看上去没有那么完美，但 C++STL就是这么做的。

但是，连接器错误在一般的语法检查是无法探测的。有可能会导致有的可怜的用户写了一大段调用了赋值运算符的代码，点编译之后松了一口气如何泡了一杯茶，结果发现报出1000+个错误的惨状。

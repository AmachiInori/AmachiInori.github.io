---
title: 图论算法：单源最短路径(二)
tags: 
  - 算法
  - 数据结构
---

我们在[上一篇文章](https://amachi.com.cn/_posts/2020-04-15-dijkstra1/)中实现了无权重图的单元最短路径算法，接下来我们考虑每一条边都有权重的情况。  

赋权路径与无权路径最大的区别就是：无权路径算法中，一个节点一旦拥有了一个距离值，那么这个距离值一定是它的最小距离值，而赋权路径显然不是这样。在赋权路径中，后来的距离很有可能比先到的距离小。  

如果按照无权路径的算法思想，我们可以有这两种思想：

1. 以无权路径模拟，将每一条边的距离展开为若干节点。如A到B的距离为3，即可模拟A到B的路径是A->B1->B2->B，再用无权路径算法求解。
2. 以无权路径的算法为基础，修改广度优先遍历时更新节点距离的方法为`min()`而不是`++`，同时取消`"已经赋值的节点不能再被遍历"`的限制。
  
想法1的漏洞是很明显的。权重的大小较小还好，如果有一条边的权重是'1E+20'呢？

那么我们就针对想法2来进行展开。
  
在此之前，我们首先需要假设你的图中没有负值圈。所谓负值圈，是循环一个周期时开销和为负值的圈。如果有这样的圈，那么所谓`“最短路径算法”`将不再是算法。

## Dijkstra 算法

首先，我们必须允许节点距离的重复赋值，也就是说，我们上节的代码：

```cpp
int unweightedPath (int totalNodeNumber, vector<vector <int>> Table, int start, int end) {
    vector<int> distance(totalNodeNumber, int(-1));
    queue<int> BFS;
    BFS.push(start);
    distance[start] = 0;
    
    int nowQueueSize;
    while (nowQueueSize = BFS.size()) {
        for (int i = 0; i < nowQueueSize; i++) {
            for (int j = 0; j < Table[BFS.front()].size(); j++) {
                if (distance[Table[BFS.front()][j]] != -1) continue;
                BFS.push(Table[BFS.front()][j]);
                distance[Table[BFS.front()][j]] = distance[BFS.front()] + 1;
            }
            BFS.pop();
        }
        if (distance[end] != -1) return distance[end];
    }
    return distance[end];
}
```

其中的`if (distance[Table[BFS.front()][j]] != -1)`必须被某种机制代替。
